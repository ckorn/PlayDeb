--- a/lzma/C/7zCrc.c
+++ b/lzma/C/7zCrc.c
@@ -1,15 +1,24 @@
-/* 7zCrc.c -- CRC32 calculation
-2009-11-23 : Igor Pavlov : Public domain */
+/* 7zCrc.c -- CRC32 init
+2010-12-01 : Igor Pavlov : Public domain */
 
 #include "7zCrc.h"
 #include "CpuArch.h"
 
 #define kCrcPoly 0xEDB88320
 
-#ifdef MY_CPU_LE
-#define CRC_NUM_TABLES 8
+#ifdef MY_CPU_X86_OR_AMD64
+  #define CRC_NUM_TABLES 8
+  UInt32 MY_FAST_CALL CrcUpdateT8(UInt32 v, const void *data, size_t size, const UInt32 *table);
+#elif defined(MY_CPU_LE)
+  #define CRC_NUM_TABLES 4
 #else
-#define CRC_NUM_TABLES 1
+  #define CRC_NUM_TABLES 5
+  #define CRC_UINT32_SWAP(v) ((v >> 24) | ((v >> 8) & 0xFF00) | ((v << 8) & 0xFF0000) | (v << 24))
+  UInt32 MY_FAST_CALL CrcUpdateT1_BeT4(UInt32 v, const void *data, size_t size, const UInt32 *table);
+#endif
+
+#ifndef MY_CPU_BE
+  UInt32 MY_FAST_CALL CrcUpdateT4(UInt32 v, const void *data, size_t size, const UInt32 *table);
 #endif
 
 typedef UInt32 (MY_FAST_CALL *CRC_FUNC)(UInt32 v, const void *data, size_t size, const UInt32 *table);
@@ -17,25 +26,6 @@
 static CRC_FUNC g_CrcUpdate;
 UInt32 g_CrcTable[256 * CRC_NUM_TABLES];
 
-#if CRC_NUM_TABLES == 1
-
-#define CRC_UPDATE_BYTE_2(crc, b) (table[((crc) ^ (b)) & 0xFF] ^ ((crc) >> 8))
-
-static UInt32 MY_FAST_CALL CrcUpdateT1(UInt32 v, const void *data, size_t size, const UInt32 *table)
-{
-  const Byte *p = (const Byte *)data;
-  for (; size > 0; size--, p++)
-    v = CRC_UPDATE_BYTE_2(v, *p);
-  return v;
-}
-
-#else
-
-UInt32 MY_FAST_CALL CrcUpdateT4(UInt32 v, const void *data, size_t size, const UInt32 *table);
-UInt32 MY_FAST_CALL CrcUpdateT8(UInt32 v, const void *data, size_t size, const UInt32 *table);
-
-#endif
-
 UInt32 MY_FAST_CALL CrcUpdate(UInt32 v, const void *data, size_t size)
 {
   return g_CrcUpdate(v, data, size, g_CrcTable);
@@ -57,18 +47,37 @@
       r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
     g_CrcTable[i] = r;
   }
-  #if CRC_NUM_TABLES == 1
-  g_CrcUpdate = CrcUpdateT1;
-  #else
   for (; i < 256 * CRC_NUM_TABLES; i++)
   {
     UInt32 r = g_CrcTable[i - 256];
     g_CrcTable[i] = g_CrcTable[r & 0xFF] ^ (r >> 8);
   }
+  
+  #ifdef MY_CPU_LE
+
   g_CrcUpdate = CrcUpdateT4;
-  #ifdef MY_CPU_X86_OR_AMD64
+  
+  #if CRC_NUM_TABLES == 8
   if (!CPU_Is_InOrder())
     g_CrcUpdate = CrcUpdateT8;
   #endif
+
+  #else
+  {
+    #ifndef MY_CPU_BE
+    UInt32 k = 1;
+    if (*(const Byte *)&k == 1)
+      g_CrcUpdate = CrcUpdateT4;
+    else
+    #endif
+    {
+      for (i = 256 * CRC_NUM_TABLES - 1; i >= 256; i--)
+      {
+        UInt32 x = g_CrcTable[i - 256];
+        g_CrcTable[i] = CRC_UINT32_SWAP(x);
+      }
+      g_CrcUpdate = CrcUpdateT1_BeT4;
+    }
+  }
   #endif
 }
--- a/lzma/C/7zCrcOpt.c
+++ b/lzma/C/7zCrcOpt.c
@@ -1,12 +1,12 @@
-/* 7zCrcOpt.c -- CRC32 calculation : optimized version
-2009-11-23 : Igor Pavlov : Public domain */
+/* 7zCrcOpt.c -- CRC32 calculation
+2010-12-01 : Igor Pavlov : Public domain */
 
 #include "CpuArch.h"
 
-#ifdef MY_CPU_LE
-
 #define CRC_UPDATE_BYTE_2(crc, b) (table[((crc) ^ (b)) & 0xFF] ^ ((crc) >> 8))
 
+#ifndef MY_CPU_BE
+
 UInt32 MY_FAST_CALL CrcUpdateT4(UInt32 v, const void *data, size_t size, const UInt32 *table)
 {
   const Byte *p = (const Byte *)data;
@@ -32,3 +32,33 @@
 }
 
 #endif
+
+
+#ifndef MY_CPU_LE
+
+#define CRC_UINT32_SWAP(v) ((v >> 24) | ((v >> 8) & 0xFF00) | ((v << 8) & 0xFF0000) | (v << 24))
+
+UInt32 MY_FAST_CALL CrcUpdateT1_BeT4(UInt32 v, const void *data, size_t size, const UInt32 *table)
+{
+  const Byte *p = (const Byte *)data;
+  for (; size > 0 && ((unsigned)(ptrdiff_t)p & 3) != 0; size--, p++)
+    v = CRC_UPDATE_BYTE_2(v, *p);
+  v = CRC_UINT32_SWAP(v);
+  table += 0x100;
+  for (; size >= 4; size -= 4, p += 4)
+  {
+    v ^= *(const UInt32 *)p;
+    v =
+      table[0x000 + (v & 0xFF)] ^
+      table[0x100 + ((v >> 8) & 0xFF)] ^
+      table[0x200 + ((v >> 16) & 0xFF)] ^
+      table[0x300 + ((v >> 24))];
+  }
+  table -= 0x100;
+  v = CRC_UINT32_SWAP(v);
+  for (; size > 0; size--, p++)
+    v = CRC_UPDATE_BYTE_2(v, *p);
+  return v;
+}
+
+#endif
--- a/lzma/C/7zVersion.h
+++ b/lzma/C/7zVersion.h
@@ -1,7 +1,8 @@
 #define MY_VER_MAJOR 9
-#define MY_VER_MINOR 20
-#define MY_VER_BUILD 0
-#define MY_VERSION "9.20"
-#define MY_DATE "2010-11-18"
+#define MY_VER_MINOR 22
+#define MY_VER_BUILD 00
+#define MY_VERSION "9.22 beta"
+#define MY_7ZIP_VERSION "9.22 beta"
+#define MY_DATE "2011-04-18"
 #define MY_COPYRIGHT ": Igor Pavlov : Public domain"
 #define MY_VERSION_COPYRIGHT_DATE MY_VERSION " " MY_COPYRIGHT " : " MY_DATE
--- a/lzma/C/CpuArch.c
+++ b/lzma/C/CpuArch.c
@@ -3,10 +3,6 @@
 
 #include "CpuArch.h"
 
-#ifdef _WIN32
-#include <windows.h>
-#endif
-
 #ifdef MY_CPU_X86_OR_AMD64
 
 #if (defined(_MSC_VER) && !defined(MY_CPU_AMD64)) || defined(__GNUC__)
@@ -74,24 +70,8 @@
   *c = c2;
   *d = d2;
 
-  #elif __PIC__
-
-  /* GCC or Clang WITH position-independent code generation */
-
-  __asm__ __volatile__ (
-    "xchgl %%ebx, %1\n"
-    "cpuid\n"
-    "xchgl %%ebx, %1\n"
-    : "=a" (*a) ,
-      "=r" (*b) ,
-      "=c" (*c) ,
-      "=d" (*d)
-    : "0" (function)) ;
-	
   #else
 
-  /* GCC or Clang WITHOUT position-independent code generation */
-
   __asm__ __volatile__ (
     "cpuid"
     : "=a" (*a) ,
--- a/lzma/C/CpuArch.h
+++ b/lzma/C/CpuArch.h
@@ -1,5 +1,5 @@
 /* CpuArch.h -- CPU specific code
-2010-10-26: Igor Pavlov : Public domain */
+2010-12-01: Igor Pavlov : Public domain */
 
 #ifndef __CPU_ARCH_H
 #define __CPU_ARCH_H
@@ -52,7 +52,7 @@
 #define MY_CPU_LE
 #endif
 
-#if defined(__BIG_ENDIAN__)
+#if defined(__BIG_ENDIAN__) || defined(__m68k__) ||  defined(__ARMEB__) || defined(__MIPSEB__)
 #define MY_CPU_BE
 #endif
 
--- a/lzma/C/Lzma2Dec.c
+++ b/lzma/C/Lzma2Dec.c
@@ -1,5 +1,5 @@
 /* Lzma2Dec.c -- LZMA2 Decoder
-2009-05-03 : Igor Pavlov : Public domain */
+2010-12-15 : Igor Pavlov : Public domain */
 
 /* #define SHOW_DEBUG_INFO */
 
@@ -330,27 +330,21 @@
 SRes Lzma2Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
     Byte prop, ELzmaFinishMode finishMode, ELzmaStatus *status, ISzAlloc *alloc)
 {
-  CLzma2Dec decoder;
+  CLzma2Dec p;
   SRes res;
   SizeT outSize = *destLen, inSize = *srcLen;
-  Byte props[LZMA_PROPS_SIZE];
-
-  Lzma2Dec_Construct(&decoder);
-
   *destLen = *srcLen = 0;
   *status = LZMA_STATUS_NOT_SPECIFIED;
-  decoder.decoder.dic = dest;
-  decoder.decoder.dicBufSize = outSize;
-
-  RINOK(Lzma2Dec_GetOldProps(prop, props));
-  RINOK(LzmaDec_AllocateProbs(&decoder.decoder, props, LZMA_PROPS_SIZE, alloc));
-  
+  Lzma2Dec_Construct(&p);
+  RINOK(Lzma2Dec_AllocateProbs(&p, prop, alloc));
+  p.decoder.dic = dest;
+  p.decoder.dicBufSize = outSize;
+  Lzma2Dec_Init(&p);
   *srcLen = inSize;
-  res = Lzma2Dec_DecodeToDic(&decoder, outSize, src, srcLen, finishMode, status);
-  *destLen = decoder.decoder.dicPos;
+  res = Lzma2Dec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
+  *destLen = p.decoder.dicPos;
   if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
     res = SZ_ERROR_INPUT_EOF;
-
-  LzmaDec_FreeProbs(&decoder.decoder, alloc);
+  Lzma2Dec_FreeProbs(&p, alloc);
   return res;
 }
--- a/lzma/C/LzmaDec.c
+++ b/lzma/C/LzmaDec.c
@@ -1,5 +1,5 @@
 /* LzmaDec.c -- LZMA Decoder
-2009-09-20 : Igor Pavlov : Public domain */
+2010-12-15 : Igor Pavlov : Public domain */
 
 #include "LzmaDec.h"
 
@@ -442,8 +442,9 @@
 
     p->processedPos += len;
     p->remainLen -= len;
-    while (len-- != 0)
+    while (len != 0)
     {
+      len--;
       dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
       dicPos++;
     }
@@ -972,28 +973,21 @@
 {
   CLzmaDec p;
   SRes res;
-  SizeT inSize = *srcLen;
-  SizeT outSize = *destLen;
-  *srcLen = *destLen = 0;
+  SizeT outSize = *destLen, inSize = *srcLen;
+  *destLen = *srcLen = 0;
+  *status = LZMA_STATUS_NOT_SPECIFIED;
   if (inSize < RC_INIT_SIZE)
     return SZ_ERROR_INPUT_EOF;
-
   LzmaDec_Construct(&p);
-  res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
-  if (res != 0)
-    return res;
+  RINOK(LzmaDec_AllocateProbs(&p, propData, propSize, alloc));
   p.dic = dest;
   p.dicBufSize = outSize;
-
   LzmaDec_Init(&p);
-  
   *srcLen = inSize;
   res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
-
+  *destLen = p.dicPos;
   if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
     res = SZ_ERROR_INPUT_EOF;
-
-  (*destLen) = p.dicPos;
   LzmaDec_FreeProbs(&p, alloc);
   return res;
 }
--- a/lzma/C/LzmaEnc.c
+++ b/lzma/C/LzmaEnc.c
@@ -1,5 +1,5 @@
 /* LzmaEnc.c -- LZMA Encoder
-2010-04-16 : Igor Pavlov : Public domain */
+2011-01-27 : Igor Pavlov : Public domain */
 
 #include <string.h>
 
@@ -46,6 +46,7 @@
 {
   p->level = 5;
   p->dictSize = p->mc = 0;
+  p->reduceSize = (UInt32)(Int32)-1;
   p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
   p->writeEndMark = 0;
 }
@@ -56,6 +57,15 @@
   if (level < 0) level = 5;
   p->level = level;
   if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
+  if (p->dictSize > p->reduceSize)
+  {
+    unsigned i;
+    for (i = 15; i <= 30; i++)
+    {
+      if (p->reduceSize <= ((UInt32)2 << i)) { p->dictSize = ((UInt32)2 << i); break; }
+      if (p->reduceSize <= ((UInt32)3 << i)) { p->dictSize = ((UInt32)3 << i); break; }
+    }
+  }
   if (p->lc < 0) p->lc = 3;
   if (p->lp < 0) p->lp = 0;
   if (p->pb < 0) p->pb = 2;
@@ -329,7 +339,6 @@
 
   SRes result;
   UInt32 dictSize;
-  UInt32 matchFinderCycles;
 
   int needInit;
 
@@ -398,7 +407,6 @@
       props.dictSize > ((UInt32)1 << kDicLogSizeMaxCompress) || props.dictSize > ((UInt32)1 << 30))
     return SZ_ERROR_PARAM;
   p->dictSize = props.dictSize;
-  p->matchFinderCycles = props.mc;
   {
     unsigned fb = props.fb;
     if (fb < 5)
--- a/lzma/C/LzmaEnc.h
+++ b/lzma/C/LzmaEnc.h
@@ -1,14 +1,12 @@
 /*  LzmaEnc.h -- LZMA Encoder
-2009-02-07 : Igor Pavlov : Public domain */
+2011-01-27 : Igor Pavlov : Public domain */
 
 #ifndef __LZMA_ENC_H
 #define __LZMA_ENC_H
 
 #include "Types.h"
 
-#ifdef __cplusplus
-extern "C" {
-#endif
+EXTERN_C_BEGIN
 
 #define LZMA_PROPS_SIZE 5
 
@@ -18,6 +16,8 @@
   UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
                       (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
                        default = (1 << 24) */
+  UInt32 reduceSize; /* estimated size of data that will be compressed. default = 0xFFFFFFFF.
+                        Encoder uses this value to reduce dictionary size */
   int lc;          /* 0 <= lc <= 8, default = 3 */
   int lp;          /* 0 <= lp <= 4, default = 0 */
   int pb;          /* 0 <= pb <= 4, default = 2 */
@@ -73,8 +73,6 @@
     const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
     ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
 
-#ifdef __cplusplus
-}
-#endif
+EXTERN_C_END
 
 #endif
--- a/lzma/C/Threads.h
+++ b/lzma/C/Threads.h
@@ -6,13 +6,6 @@
 
 #include "Types.h"
 
-#ifdef _WIN32
-#include <windows.h>
-typedef DWORD WRes;
-#else
-typedef int WRes;
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
--- a/lzma/C/Types.h
+++ b/lzma/C/Types.h
@@ -6,6 +6,10 @@
 
 #include <stddef.h>
 
+#ifdef _WIN32
+#include <windows.h>
+#endif
+
 #ifndef EXTERN_C_BEGIN
 #ifdef __cplusplus
 #define EXTERN_C_BEGIN extern "C" {
@@ -38,12 +42,14 @@
 
 typedef int SRes;
 
-#ifndef RINOK
-#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
+#ifdef _WIN32
+typedef DWORD WRes;
+#else
+typedef int WRes;
 #endif
 
-#if defined(__APPLE__) && !__LP64__
-#define _LZMA_UINT32_IS_ULONG
+#ifndef RINOK
+#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
 #endif
 
 typedef unsigned char Byte;
--- a/lzma/history.txt
+++ b/lzma/history.txt
@@ -1,6 +1,14 @@
 HISTORY of the LZMA SDK
 -----------------------
 
+9.21 beta      2011-04-11
+-------------------------	
+- New class FString for file names at file systems.
+- Speed optimization in CRC code for big-endian CPUs.
+- The BUG in Lzma2Dec.c was fixed:
+    Lzma2Decode function didn't work.
+
+
 9.18 beta      2010-11-02
 -------------------------	
 - New small SFX module for installers (SfxSetup).
--- a/lzma/lzma.txt
+++ b/lzma/lzma.txt
@@ -1,4 +1,4 @@
-LZMA SDK 9.20
+LZMA SDK 9.22
 -------------
 
 LZMA SDK provides the documentation, samples, header files, libraries, 
@@ -24,6 +24,12 @@
   1) PPMd var.H (2001): Dmitry Shkarin
   2) SHA-256: Wei Dai (Crypto++ library)
 
+You can copy, modify, distribute and perform LZMA SDK code, even for commercial purposes,
+all without asking permission.
+
+LZMA SDK code is compatible with open source licenses, for example, you can 
+include it to GNU GPL or GNU LGPL code.
+
 
 LZMA SDK Contents
 -----------------
